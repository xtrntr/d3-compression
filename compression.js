runAnimation = function() {
    // var ASCII = "01001001 01101110 00100000 01100001 01101110 01101111 01110100 01101000 01100101 01110010 00100000 01101101 01101111 01101101 01100101 01101110 01110100 00100000 01100100 01101111 01110111 01101110 00100000 01110111 01100101 01101110 01110100 00100000 01000001 01101100 01101001 01100011 01100101 00100000 01100001 01100110 01110100 01100101 01110010 00100000 01101001 01110100 00101100 00100000 01101110 01100101 01110110 01100101 01110010 00100000 01101111 01101110 01100011 01100101 00100000 01100011 01101111 01101110 01110011 01101001 01100100 01100101 01110010 01101001 01101110 01100111 00100000 01101000 01101111 01110111 00100000 01101001 01101110 00100000 01110100 01101000 01100101 00100000 01110111 01101111 01110010 01101100 01100100 00100000 01110011 01101000 01100101 00100000 01110111 01100001 01110011 00100000 01110100 01101111 00100000 01100111 01100101 01110100 00100000 01101111 01110101 01110100 00100000 01100001 01100111 01100001 01101001 01101110 00101110 00100000 01010100 01101000 01100101 00100000 01110010 01100001 01100010 01100010 01101001 01110100 00101101 01101000 01101111 01101100 01100101 00100000 01110111 01100101 01101110 01110100 00100000 01110011 01110100 01110010 01100001 01101001 01100111 01101000 01110100 00100000 01101111 01101110 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01110100 01110101 01101110 01101110 01100101 01101100 00100000 01100110 01101111 01110010 00100000 01110011 01101111 01101101 01100101 00100000 01110111 01100001 01111001 00101100 00100000 01100001 01101110 01100100 00100000 01110100 01101000 01100101 01101110 00100000 01100100 01101001 01110000 01110000 01100101 01100100 00100000 01110011 01110101 01100100 01100100 01100101 01101110 01101100 01111001 00100000 01100100 01101111 01110111 01101110 00101100 00100000 01110011 01101111 00100000 01110011 01110101 01100100 01100100 01100101 01101110 01101100 01111001 00100000 01110100 01101000 01100001 01110100 00100000 01000001 01101100 01101001 01100011 01100101 00100000 01101000 01100001 01100100 00100000 01101110 01101111 01110100 00100000 01100001 00100000 01101101 01101111 01101101 01100101 01101110 01110100 00100000 01110100 01101111 00100000 01110100 01101000 01101001 01101110 01101011 00100000 01100001 01100010 01101111 01110101 01110100 00100000 01110011 01110100 01101111 01110000 01110000 01101001 01101110 01100111 00100000 01101000 01100101 01110010 01110011 01100101 01101100 01100110 00100000 01100010 01100101 01100110 01101111 01110010 01100101 00100000 01110011 01101000 01100101 00100000 01100110 01101111 01110101 01101110 01100100 00100000 01101000 01100101 01110010 01110011 01100101 01101100 01100110 00100000 01100110 01100001 01101100 01101100 01101001 01101110 01100111 00100000 01100100 01101111 01110111 01101110 00100000 01100001 00100000 01110110 01100101 01110010 01111001 00100000 01100100 01100101 01100101 01110000 00100000 01110111 01100101 01101100 01101100 00101110 00100000 01000101 01101001 01110100 01101000 01100101 01110010 00100000 01110100 01101000 01100101 00100000 01110111 01100101 01101100 01101100 00100000 01110111 01100001 01110011 00100000 01110110 01100101 01110010 01111001 00100000 01100100 01100101 01100101 01110000 00101100 00100000 01101111 01110010 00100000 01110011 01101000 01100101 00100000 01100110 01100101 01101100 01101100 00100000 01110110 01100101 01110010 01111001 00100000 01110011 01101100 01101111 01110111 01101100 01111001 00101100 00100000 01100110 01101111 01110010 00100000 01110011 01101000 01100101 00100000 01101000 01100001 01100100 00100000 01110000 01101100 01100101 01101110 01110100 01111001 00100000 01101111 01100110 00100000 01110100 01101001 01101101 01100101 00100000 01100001 01110011 00100000 01110011 01101000 01100101 00100000 01110111 01100101 01101110 01110100 00100000 01100100 01101111 01110111 01101110 00100000 01110100 01101111 00100000 01101100 01101111 01101111 01101011 00100000 01100001 01100010 01101111 01110101 01110100 00100000 01101000 01100101 01110010 00100000 01100001 01101110 01100100 00100000 01110100 01101111 00100000 01110111 01101111 01101110 01100100 01100101 01110010 00100000 01110111 01101000 01100001 01110100 00100000 01110111 01100001 01110011 00100000 01100111 01101111 01101001 01101110 01100111 00100000 01110100 01101111 00100000 01101000 01100001 01110000 01110000 01100101 01101110 00100000 01101110 01100101 01111000 01110100 00101110 00100000 01000110 01101001 01110010 01110011 01110100 00101100 00100000 01110011 01101000 01100101 00100000 01110100 01110010 01101001 01100101 01100100 00100000 01110100 01101111"
    var ASCII = "01000001 01101100 01101001 01100011 01100101 00100000 01110111 01100001 01110011 00100000 01100010 01100101 01100111 01101001 01101110 01101110 01101001 01101110 01100111 00100000 01110100 01101111 00100000 01100111 01100101 01110100 00100000 01110110 01100101 01110010 01111001 00100000 01110100 01101001 01110010 01100101 01100100 00100000 01101111 01100110 00100000 01110011 01101001 01110100 01110100 01101001 01101110 01100111 00100000 01100010 01111001 00100000 01101000 01100101 01110010 00100000 01110011 01101001 01110011 01110100 01100101 01110010 00100000 01101111 01101110 00100000 01110100 01101000 01100101 00100000 01100010 01100001 01101110 01101011 00101100 00100000 01100001 01101110 01100100 00100000 01101111 01100110 00100000 01101000 01100001 01110110 01101001 01101110 01100111 00100000 01101110 01101111 01110100 01101000 01101001 01101110 01100111 00100000 01110100 01101111 00100000 01100100 01101111 00111010 00100000 01101111 01101110 01100011 01100101 00100000 01101111 01110010 00100000 01110100 01110111 01101001 01100011 01100101 00100000 01110011 01101000 01100101 00100000 01101000 01100001 01100100 00100000 01110000 "
    var huffman_encoded = "1000110 1000111 1100 00110 000 01 111100 11011 11010 01 111101 000 11111 1100 1110 1110 1100 1110 11111 01 1011 1001 01 11111 000 1011 01 101000 000 10101 100001 01 1011 1100 10101 000 00111 01 1001 100010 01 11010 1100 1011 1011 1100 1110 11111 01 111101 100001 01 0010 000 10101 01 11010 1100 11010 1011 000 10101 01 1001 1110 01 1011 0010 000 01 111101 11011 1110 1010010 1010011 01 11011 1110 00111 01 1001 100010 01 0010 11011 101000 1100 1110 11111 01 1110 1001 1011 0010 1100 1110 11111 01 1011 1001 01 00111 1001 1000001 01 1001 1110 00110 000 01 1001 10101 01 1011 111100 1100 00110 000 01 11010 0010 000 01 0010 11011 00111 01 1000000 "
        // var huffman_encoded = "100000111 1001 00 11111 1001 1011 1100 0100 011 11011 00 1110011 1011 1110011 011 1001 1100 00 11101 1011 10100 1001 00 10100 011 1001 1100 00 01011100 11110 10101 1000000 011 00 11111 111000 1100 011 11011 00 10101 1100 010101 00 1001 011 0101111 011 11011 00 1011 1001 1000000 011 00 1000000 1011 1001 11010 10101 11101 011 11011 10101 1001 100010 00 0100 1011 10100 00 10101 1001 00 1100 0100 011 00 10100 1011 11011 11110 11101 00 11010 0100 011 00 10100 11111 11010 00 1100 1011 00 100010 011 1100 00 1011 010110 1100 00 11111 100010 11111 10101 1001 0101000 00 100000100 0100 011 00 11011 11111 1110010 1110010 10101 1100 100000101 0100 1011 11110 011 00 10100 011 1001 1100 00 11010 1100 11011 11111 10101 100010 0100 1100 00 1011 1001 00 11110 10101 0101001 011 00 11111 00 1100 010110 1001 1001 011 11110 00 111000 1011 11011 00 11010 1011 1110011 011 00 10100 11111 100001 010101 00 11111 1001 11101 00 1100 0100 011 1001 00 11101 10101 100011 100011 011 11101 00 11010 010110 11101 11101 011 1001 11110 100001 00 11101 1011 10100 1001 010101 00 11010 1011 00 11010 010110 11101 11101 011 1001 11110 100001 00 1100 0100 11111 1100 00 01011100 11110 10101 1000000 011 00 0100 11111 11101 00 1001 1011 1100 00 11111 00 1110011 1011 1110011 011 1001 1100 00 1100 1011 00 1100 0100 10101 1001 0101001 00 11111 1110010 1011 010110 1100 00 11010 1100 1011 100011 100011 10101 1001 100010 00 0100 011 11011 11010 011 11110 111000 00 1110010 011 111000 1011 11011 011 00 11010 0100 011 00 111000 1011 010110 1001 11101 00 0100 011 11011 11010 011 11110 111000 00 111000 11111 11110 11110 10101 1001 100010 00 11101 1011 10100 1001 00 11111 00 0101111 011 11011 100001 00 11101 011 011 100011 00 10100 011 11110 11110 0101000 00 010111010 10101 1100 0100 011 11011 00 1100 0100 011 00 10100 011 11110 11110 00 10100 11111 11010 00 0101111 011 11011 100001 00 11101 011 011 100011 010101 00 1011 11011 00 11010 0100 011 00 111000 011 11110 11110 00 0101111 011 11011 100001 00 11010 11110 1011 10100 11110 100001 010101 00 111000 1011 11011 00 11010 0100 011 00 0100 11111 11101 00 100011 11110 011 1001 1100 100001 00 1011 111000 00 1100 10101 1110011 011 00 11111 11010 00 11010 0100 011 00 10100 011 1001 1100 00 11101 1011 10100 1001 00 1100 1011 00 11110 1011 1011 0101001 00 11111 1110010 1011 010110 1100 00 0100 011 11011 00 11111 1001 11101 00 1100 1011 00 10100 1011 1001 11101 011 11011 00 10100 0100 11111 1100 00 10100 11111 11010 00 100010 1011 10101 1001 100010 00 1100 1011 00 0100 11111 100011 100011 011 1001 00 1001 011 010111011 1100 0101000 00 100000110 10101 11011 11010 1100 010101 00 11010 0100 011 00 1100 11011 10101 011 11101 00 1100 1011"
    var current_block = 0
    var uncompressed_data = objectify(ASCII, "ascii")
    var compressed_data = objectify(huffman_encoded, "huffman")
    var ASCII_len = ASCII.length, //
        huffman_len = huffman_encoded.length,
        destination_index = 0;
    // 960/500 gives a 1.92 ratio

    var speeds = getSpeeds(2000);

    const SCALE = 3;
    const CELL_SIZE = 20;
    const SQUARE_WIDTH = 32;
    const BORDER_WIDTH = 5;
    const CENTER_X = SQUARE_WIDTH * CELL_SIZE / 2 - 2 * SQUARE_WIDTH * SCALE;
    const CENTER_Y = SQUARE_WIDTH * CELL_SIZE / 2 - SQUARE_WIDTH * SCALE / 2;
    const MIN_SPEED = 200;

    var indexToPixel = function(index) {
        row = Math.floor(index / SQUARE_WIDTH);
        col = index % SQUARE_WIDTH;
        return {
            x: col * CELL_SIZE + 2 * BORDER_WIDTH,
            y: row * CELL_SIZE + 2 * BORDER_WIDTH
        };
    };

    var svgContainer, rectangle;

    svgContainer = d3.select("body").append("svg")
        .attr("width", 800)
        .attr("height", 800);

    function initialize() {
        var boundingSquare = svgContainer
            .append("rect")
            .attr("width", SQUARE_WIDTH * CELL_SIZE + 2 * BORDER_WIDTH)
            .attr("height", SQUARE_WIDTH * CELL_SIZE + 2 * BORDER_WIDTH)
            .attr("x", BORDER_WIDTH)
            .attr("y", BORDER_WIDTH)
            .style("stroke", "red")
            .style("stroke-width", BORDER_WIDTH + "px")
            .style("fill", "white")
    }

    initialize();

    function update(data) {
        rectangles = svgContainer.selectAll(".bit")
            .data(data);

        rectangles.enter()
            .append("rect")
            .attr("width", CELL_SIZE)
            .attr("height", CELL_SIZE)
            .attr("class", "bit")
            .style("stroke", "#999999")
            .style("opacity", 1)
            .style("stroke-width", "1px")
            .style("transform", function(d) {
                return "translate(" + indexToPixel(d.index).x + "px, " + indexToPixel(d.index).y + "px)";
            })
            .style("fill", function(d) {
                return (d.value == "0") ? "white" : "black"
            });

        rectangles
            .attr("id", function(d) {
                return "square-" + String(d.index);
            })
            .style("fill", function(d) {
                return (d.value == "0") ? "white" : "black"
            })
            .style("transform", function(d) {
                return "translate(" + indexToPixel(d.index).x + "px, " + indexToPixel(d.index).y + "px)";
            });

        uncompressed_bits = _.filter(uncompressed_data, function(bits) {
            return bits.block_idx > current_block
        })
        compressed_bits = _.filter(compressed_data, function(bits) {
            return bits.block_idx <= current_block
        })

        uncompressed_block = _.filter(uncompressed_data, function(bits) {
            return bits.block_idx == current_block
        })
        compressed_block = _.filter(compressed_data, function(bits) {
            return bits.block_idx == current_block
        })
        compressed_values = compressed_block.map(function(d) {
            return d.value
        })
        compressed_length = compressed_block.length

        if (speeds.timeoutSpeed > MIN_SPEED) {
            d3.selectAll(".bit")
                .filter(function(d) {
                    return d.block_idx == current_block && d.label == "ascii"
                })
                .each(function(d, i) {
                    d3.select(this)
                        .transition()
                        .duration(speeds.movementSpeed)
                        .style("transform",
                            function(d) {
                                return "translate(" + (CENTER_X + d.bit_idx * CELL_SIZE * SCALE) + "px, " + CENTER_Y + "px) scale(" + SCALE + ")"
                            })
                        .transition()
                        .duration(speeds.compressionSpeed)
                        .style("transform",
                            function(d) {
                                if (compressed_length > d.bit_idx) {
                                    return "translate(" + (CENTER_X + d.bit_idx * CELL_SIZE * SCALE) + "px, " + CENTER_Y + "px) scale(" + SCALE + ")"
                                } else {
                                    return "translate(" + (CENTER_X + compressed_values.indexOf("1") * CELL_SIZE * SCALE) + "px, " + CENTER_Y + "px) scale(" + SCALE + ")"
                                }
                            })
                        .style("fill", function(d) {
                            if (compressed_length > d.bit_idx) {
                                return (compressed_block[d.bit_idx].value == "0") ? "white" : "black"
                            };
                        })
                        .transition()
                        .duration(speeds.movementSpeed)
                        .style("transform",
                            function(d) {
                                if (compressed_length > d.bit_idx) {
                                    return "translate(" + indexToPixel(compressed_bits.length + d.bit_idx - compressed_length).x + "px, " + indexToPixel(compressed_bits.length + d.bit_idx - compressed_length).y + "px)";
                                } else {
                                    return "translate(" + indexToPixel(compressed_bits.length + compressed_values.indexOf("1") - compressed_length).x + "px, " + indexToPixel(compressed_bits.length + compressed_values.indexOf("1") - compressed_length).y + "px)";
                                }
                            })
                });
        } else {
            rectangles.exit()
                .transition()
                .duration(speeds.timeoutSpeed)
                .style("opacity", 0)
                .remove();
        };

        var new_data = compressed_bits.concat(uncompressed_bits);
        current_block++;
        if (huffman_encoded.replace(/\s+/g, '').length <= new_data.length) {
            setTimeout(function(d) {
                speeds = getSpeeds(Math.max(speeds.timeoutSpeed / 2, MIN_SPEED)) // what function?
                update(d);
                console.log(speeds)
            }, speeds.timeoutSpeed, new_data);
        }
    }

    function getSpeeds(timeoutSpeed) {
        return {
            timeoutSpeed: timeoutSpeed,
            compressionSpeed: timeoutSpeed / 2,
            movementSpeed: (timeoutSpeed - timeoutSpeed / 2) / 3
        }
    }

    function objectify(data, label) {
        var objs = [],
            index = 0;
        var blocks = data.split(" "); // split into blocks
        blocks.forEach(function(block, block_idx) {
            var bits = block.split("");
            bits.forEach(function(bit, bit_idx) {
                obj = {
                    block_idx: block_idx, // this is which block it's a part of
                    bit_idx: bit_idx, // this is the index of the bit inside the block.
                    value: bit, // this is the value
                    index: index++, // this is the index in the whole text. this is the original index. i guess not the "global index" . i really have a difficult time tracking down the bugs... i can't tell if they're mine or they're just me not knowing how to use d3
                    label: label // ascii or huffman. because i only want to highlight the ascii.
                };
                objs.push(obj)
            });
        })
        return objs;
    }

    update(uncompressed_data.reverse());
}